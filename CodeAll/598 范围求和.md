# 598 范围求和

### 题目描述

- 给定一个初始元素全部为 **0**，大小为 m*n 的矩阵 **M** 以及在 **M** 上的一系列更新操作。
- 操作用二维数组表示，其中的每个操作用一个含有两个**正整数 a** 和 **b** 的数组表示，含义是将所有符合 **0 <= i < a** 以及 **0 <= j < b** 的元素 **M[i][j]** 的值都**增加 1**。
- 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

> 示例：
>
> ```
> 输入: 
> m = 3, n = 3
> operations = [[2,2],[3,3]]
> 输出: 4
> 解释: 
> 初始状态, M = 
> [[0, 0, 0],
>  [0, 0, 0],
>  [0, 0, 0]]
>  执行完操作 [2,2] 后, M = 
> [[1, 1, 0],
>  [1, 1, 0],
>  [0, 0, 0]]
>  执行完操作 [3,3] 后, M = 
> [[2, 2, 1],
>  [2, 2, 1],
>  [1, 1, 1]]
>  M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
> ```

### 我的解法

- 看着题目很长，其实理解一下特别简单，由于它是覆盖式地加法，所以第一个元素一定会被加到，也就是说，可以把执行的操作看成在给m*n矩形上色，每上一次，颜色加深，那么最终颜色最深的部位就是答案，显然，所有操作后重叠的最小面积就是答案。那么显然，ops数组中x和y的最小值就是结果，那么m和n没用了吗，当然不是，最小值也不能大于m和n

```java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        int x=m,y=n;
        for(int[] op:ops){
            x=Math.min(x,op[0]);
            y=Math.min(y,op[1]);
        }
        return x*y;
    }
}
```

### 官方解法

- 一样的,这题so easy