排列
给定一个整数n，将数字1～n排成一排，将会有很多种排列方法。
现在，请你按照字典序将所有的排列方法输出。

输入格式
共一行，包含一个整数n。

输出格式
按字典序输出所有排列方案，每个方案占一行。
数据范围
1<=n<=9
如3，输出123 132 213 231 312 321
###########
#include <iostream>

using namespace std;

const int N = 10;

int n;

void dfs(int u, int nums[], bool st[])
{
    if (u > n) 
    {
        for (int i = 1; i <= n; i ++) cout << nums[i] << ' ';
        cout << endl;
    }
    else
    {
        for (int i = 1; i <= n; i ++)
        if (!st[i])
        {
            st[i] = true;
            nums[u] = i;
            dfs(u + 1, nums, st);
            st[i] = false;
        }
    }
}

int main()
{
    cin >> n;
    int nums[N];
    bool st[N] = {0};
    dfs(1, nums, st);
    return 0;
}
###########
先上代码，深度优先算法，通过递归的方式遍历所有可能，有点类似于一个萝卜一个坑，占了坑的地方设为true；没占坑的地方按顺序占，
字典顺序正是数字大小顺序，所以小的在前面，n个循环代表了每个整数放第一位的情况，然后递归的时候，有一个循环由于st为true，所以有效循环是n-1个，即剩下数字的排列
正好也是按照去掉第一个数字后的数字大小排列，所以一共有n！次排列。同时不要忘了，排列结束后重置为false，方便重新占坑。
