# 798. 得分最高的最小轮调

### 题目描述

给你一个数组 `nums`，我们可以将它按一个非负整数 `k` 进行轮调，这样可以使数组变为 `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]` 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

- 例如，数组为 `nums = [2,4,1,3,0]`，我们按 `k = 2` 进行轮调后，它将变成 `[1,3,0,2,4]`。这将记为 `3` 分，因为 `1 > 0` [不计分]、`3 > 1` [不计分]、`0 <= 2` [计 1 分]、`2 <= 3` [计 1 分]，`4 <= 4` [计 1 分]。

在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 `k` 。如果有多个答案，返回满足条件的最小的下标 `k` 。**示例 1：**

```
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
```

### 我的解答

不会

### 官方解答

不是很看得懂，有个评论解答很不错

- 首先得到每个元素在等于自己下标时需要进行的步数，然后以步数为索引计数，这样就得到了k为某个数时，此时下标等于索引的元素个数，这些元素将在下一次左移时全部变成大于下标，上次得到的分就要减掉，而小于索引的将继续小于索引，大于索引的可能大于可能等于，但是得分和失分都不变
- 但是第一个元素不管怎样都会得分，这里有一点重合的就是元素0在索引0处，左移好像不会失分，但由于移动到末尾会得分，而0在0处也会得分，所以一起统计，也满足递推式，或者这样理解
- 0在0处得到的分失去了，却得到了在末尾的分数

```java
class Solution {
    public int bestRotation(int[] nums) {
        int n = nums.length, val = 0;
        for(int i = 0; i < n; i++) if(nums[i] <= i) val++;  //算初始值
        int[] steps = new int[n];    //每个k对应多少下标相等的
        for(int i = 0; i < n; i++) {
            if(nums[i] <= i) steps[i - nums[i]]++;
            else steps[i + n - nums[i]]++;
            
        }
        int ans = 0, maxval = val;
        for(int i = 1; i < n; i++) {
            //状态转移，多移一位，上次的分数要减去上次刚好值与下标相等的元素（多移一位就丧失分数）
            //首位移动到末位必多一分
            val = val - steps[i - 1] + 1; 
            if(val > maxval) {
                ans = i;
                maxval = val;
            }
        }
        return ans;
    }
}
```

