给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。

 

示例 1：

输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
########################
一开始的想法是按照操作步骤来一步步地得到答案，然后统计经过的次数。使用空间的递归将会爆栈，使用时间循环也会超时。
一时不知道怎么做了。原来算法题也是需要自己转换成另一个相同的问题之类的，以后题目做不出来可以试一下。
可以想到，一直到最后一步操作最小值都是在+1的，因为每次操作都有n-1个数需要加一，所以最小值不可能变成最大值，每次都有n-2个比它大的数一起+1。


所以最终数组所有数相等的时候，假设进行了k次操作，那么最终数组为都是minm+k的数，总和为n*(minm+k),而同时这个整体进行了k次的＋(n-1)操作
所以设原来的总和sum,sum+(n-1)*k = n*(minm+k); 化简的k = sum - n*minm;所以代码方面的问题就不存在了.

class Solution {
    public int minMoves(int[] nums) {
        int minm = nums[0],sum=0;
        for(int i=0;i<nums.length;i++){
            if(minm>nums[i]) minm = nums[i];
            sum+=nums[i];
        }
        return sum-nums.length*minm;
    }
}
###############
为了防止溢出,可以先算出最小值,每次加上nums[i]-minm;还有另外一种解释也可以得到这个表达式,就是每次只操作最大值-1,效果相同,那么最终得到的是所有数都为最小值.操作次数为sum-n*minm
