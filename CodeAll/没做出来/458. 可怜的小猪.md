# 458. 可怜的小猪

### 题目描述

有` buckets` 桶液体，其中 **正好** 有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 `minutesToTest` 分钟时间来确定哪桶液体是有毒的。

喂猪的规则如下：

1. 选择若干活猪进行喂养
2. 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
3. 小猪喝完水后，必须有 `minutesToDie` 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。
4. 过了 `minutesToDie` 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。
5. 重复这一过程，直到时间用完。

给你桶的数目 `buckets` ，`minutesToDie` 和 `minutesToTest` ，返回在规定时间内判断哪个桶有毒所需的 **最小** 猪数。

> 示例：
>
> ```
> 输入：buckets = 1000, minutesToDie = 15, minutesToTest = 60
> 输出：5
> ```
>
> ```
> 输入：buckets = 4, minutesToDie = 15, minutesToTest = 15
> 输出：2
> ```
>
> ```
> 输入：buckets = 4, minutesToDie = 15, minutesToTest = 30
> 输出：2
> ```

### 我的解答

- 看的我一头雾水，也没解释为什么5只猪可以判断1000桶
- 看提示了，2只猪如何一次性算出4桶的，仔细琢磨了一下，第一只猪吃1、2；第二只猪吃2、3；如果都死了说明是2， 如果猪1死猪二活说明是1， 如果猪二死猪一活说明是3， 都活着说明是4.
- 其实这个时候我想到了编码，也就是00 01 10 11表示四个状态， 但我没想明白次数和这个编码是怎么扯上关系的，猪不就只有死活两个状态吗？那不就只能$$2^n$$个桶吗
- 最后一个提示竟然直接给了结果 $$(T+1)^n>=N$$, 其中n为猪数, 找到这个最小n
- 说明猪的状态是T+1,这个时候想起只有一次的时候状态为2,也就是死活,终于想到, 如果有两次测试,那么猪有三个状态: 
  - 第一次死;
  - 第一次活第二次死
  - 两次都活下来
- 所以每只猪都有(T+1)个状态, n只猪就能表示$$(T+1)^n$$个状态, 比桶的数量多就行了

```java
class Solution {
    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int codenum = minutesToTest/minutesToDie+1;
        for(int i=0;i<11;i++){
            if(Math.pow(codenum,i)>=buckets) return i;
        }
        return 10;
    }
}
```

### 评论解法

- 更合理,也更好懂,因为编码比较理论,不一定能证明出来;评论是通过将小猪看成维度来解决
- 比如有两只猪的话,二维空间,一只猪负责喝行桶,一只猪负责列,当两只猪都死的时候就确定了行和列也就确定了桶,当前面n-1行和n-1列都没有猪死的时候,最后一个桶(n,n)就是毒桶,有n只猪就是n维,同时一行的桶数为回合数+1,因为最后一回合没必要测试,一定是毒药.
- 所以总的桶数为$$(T+1)^n>=N$$ 代码一样
- ![img](https://mubu.com/document_image/f57dcc8a-3eb8-4830-97ec-7738301759a5-455593.jpg)

### 官方解答

- 估计差不多
- 好吧差很多,用的动态规划,但是我感觉有点问题,因为默认每一轮都存在所有小猪都死或者都不死的情况,没有证明为什么这样是最小数目.不过这样能表示最多的信息量倒是真的.
- [可怜的小猪 - 可怜的小猪 - 力扣](https://leetcode-cn.com/problems/poor-pigs/solution/ke-lian-de-xiao-zhu-by-leetcode-solution-z0h7/)