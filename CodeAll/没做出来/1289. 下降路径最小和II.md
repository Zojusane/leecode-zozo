# 1289. 下降路径最小和II

### 题目描述

给你一个整数方阵 `arr` ，定义「非零偏移下降路径」为：从 `arr` 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

请你返回非零偏移下降路径数字和的最小值。

**示例 1：**

```
输入：arr = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
```

### 我的解答

- 想当然的认为，最终的结果一定是由每一行的最小值和次小值构成的，然后再对每行的这两个值进行dp动态规划，实际上是错误的，最后一个案例，[[1,99,99] [0,2,1] [99,99,4]], 答案就是1+2+4,但是2并不是第二行的最小值和次小值. 
- 所以还是应该直接dp,对每一个坐标而言,将上一行的最小值加上,如果上一行最小值和这一行同列,就加上次小值,注意这里加的就不是元数据,而是dp数据

```java
class Solution {
    int MAX = Integer.MAX_VALUE;
    public int minFallingPathSum(int[][] arr) {
        int n = arr.length;
        int[][] f = new int[n][n];
        
        // i1 代表最小值列下标，i2 代表次小值列下标
        int i1 = -1, i2 = -1;
        
        // 先转移第一行
        for (int i = 0; i < n; i++) {
        
            // 更新动规值
            int val = arr[0][i];
            f[0][i] = val;
            
            // 更新 i1 和 i2
            if (val < (i1 == -1 ? MAX : f[0][i1])) {
                i2 = i1;
                i1 = i;
            } else if (val < (i2 == -1 ? MAX : f[0][i2])) {
                i2 = i;
            }
        }
        
        // 再转移剩余行
        for (int i = 1; i < n; i++) {
        
            // 当前转移第 i 行，使用临时变量保存转移过程中的「最小值列下标」&「次小值列下标」
            int ti1 = -1, ti2 = -1;
            
            for (int j = 0; j < n; j++) {
                f[i][j] = MAX;
                int val = arr[i][j];
                
                // 更新动规值
                // 可以选择「最小值」的列选择「最小值」
                if (j != i1) {
                    f[i][j] = f[i - 1][i1] + val;
                    
                // 不能选择「最小值」的列选择「次小值」
                } else {
                    f[i][j] = f[i - 1][i2] + val;
                }
                
                // 更新 ti1 和 ti2
                if (f[i][j] < (ti1 == -1 ? MAX : f[i][ti1])) {
                    ti2 = ti1;
                    ti1 = j;
                } else if (f[i][j] < (ti2 == -1 ? MAX : f[i][ti2])) {
                    ti2 = j;
                }
            }
            
            // 使用临时变量更新 i1 和 i2
            i1 = ti1; i2 = ti2;
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            ans = Math.min(ans, f[n-1][i]);
        }
        return ans;
    }
}
```

